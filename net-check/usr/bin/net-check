#!/usr/bin/env bash

# net-check script
#
# This script is run periodically by cron (e.g. every 5 minutes). When
# run, we test the connection to Internet by pinging a solid host. Ping
# is tried a few times with quick retry, sending a few packets.
# If all pings fail, we will increment the ping failure counter and wait
# to be run again. When the failure counter exceeds a configured value,
# we do ifdown and ifup to all requested interfaces. If no interfaces are
# configured, restart those used by default routes (usually just ppp0 or eth0).
# If the ping succeeds, we reset the failure counter to 0.
#
# The idea behind retrying slowly and carefully is permitting the network
# to self-heal before we take drastic measures, potentially tipping over an
# already unstable system (e.g. when GSM signal is weak or something is
# overloaded).
#
# Initial idea from:http://technotes.nofailkale.com/2014/03/how-to-fix-raspberry-pi-wi-fi.html

#######################################################################
#                            Configuration                            #
#######################################################################

# Load configuration file
source /etc/net-check.conf

SCRIPT_NAME=`basename $0`
BIN_LOGGER="/usr/bin/logger"
BIN_PING="/bin/ping"
BIN_IP="/sbin/ip"
# If ping fails _more_ times than the set limit, we restart the network.
# When set to 5, the 6th consecutive failure will trigger a network restart.
FAILURE_LIMIT=5
# Delay between quick ping retry attempts
RETRY_DELAY_S=10
# Delay between issuing stop and start of an interface.
# Must be long enough to accommodate 3G shutdown (15+ s)
IF_RESTART_DELAY_S=20


#######################################################################
#                              Functions                              #
#######################################################################

function log_error()
{
  LOG_MSG="$1"
  $BIN_LOGGER -s -p cron.error -t $SCRIPT_NAME -i "$LOG_MSG"
}

function log_info()
{
  LOG_MSG="$1"
  $BIN_LOGGER -s -p cron.info -t $SCRIPT_NAME -i "$LOG_MSG"
}

# Discover a list of default IPv4 interfaces on the system (often there are only 1)
function list_default_interfaces()
{
  IFLIST=$($BIN_IP -family inet route show to default | sed -r 's/.*[[:space:]]+dev[[:space:]]+([^[:space:]]*)[[:space:]]+.*/\1/')
  RESULT=$?
  if ((RESULT==0)); then
    echo $IFLIST
  fi
  return $RESULT
}

# Write a number to a file
#  @param $1 [required] Name of the file which stores the number
#  @param $2 [required] Number to write
#  @return 0 if succeeded, error code otherwise
function number_set()
{
  STORAGE="$1"
  NUMBER="$2"
  if [[ -z $STORAGE || -z $NUMBER ]]; then
    log_error "Write failed: missing storage location [$STORAGE] or number [$NUMBER]"
    return 1
  fi

  if [[ ! $NUMBER =~ ^-?[0-9]+$ ]]; then
    log_error "Write failed: cannot write non-numeric [$NUMBER] to [$STORAGE]"
    return 4
  fi

  if [[ ! -f "$STORAGE" ]]; then
    if ! touch "$STORAGE"; then
      log_error "Write failed: cannot create file [$STORAGE]"
      return 2
    fi
  fi

  if ! echo "$NUMBER" > "$STORAGE"; then
    log_error "Write failed: [$NUMBER] to [$STORAGE]"
    return 3
  else
    log_info "Wrote [$NUMBER] to [$STORAGE]"
    echo $NUMBER
    return 0
  fi
}

# Read a 0 or positive number from a file and echo to stdout
#  @param $1 [required] Name of the file which stores the number
#  @return 0 if succeeded, error code otherwise
function number_get()
{
  STORAGE="$1"
  NUMBER=""
  if [[ -z "$STORAGE" ]]; then
    log_error "Read failed, missing file [$STORAGE]"
    return 1
  fi

  if [[ ! -r $STORAGE ]]; then
    log_error "Read failed, file [$STORAGE] missing or not readable"
    return 2
  fi

  if ! NUMBER=$(cat "$STORAGE"); then
    log_error "Read failed: [$NUMBER] from [$STORAGE]"
    return 3
  elif [[ ! $NUMBER =~ -?^[0-9]+$ ]]; then
    log_error "Read failed, non-numeric [$NUMBER] from [$STORAGE]"
    return 4
  else
    log_info "Read [$NUMBER] from [$STORAGE]"
    echo $NUMBER
    return 0
  fi
}

# Read fail count
function get_fail_count()
{

  FAIL_COUNT=$(number_get "$FAILLOG")
  if (($? != 0)); then
    log_error "Failed to read fail count [$FAIL_COUNT], error [$?]"
    # Report success to avoid restarting network unnecessarily
    echo 0
    return 1
  else
    echo $FAIL_COUNT
    return 0
  fi
}

# Increment fail count
# @param $1 [required] Increment amount
function fail_count_inc()
{
  INCREMENT=$1
  if [[ -z "$INCREMENT" ]]; then
    log_error "Increment failed, missing amount [$INCREMENT]"
    return 1
  fi
  # Read current
  FAIL_COUNT=$(number_get "$FAILLOG")
  RESULT=$?
  if ((RESULT == 0)); then
    # Increment fail counter
    ((FAIL_COUNT = FAIL_COUNT + 1))
  else
    log_error "Failed to read fail count [$FAIL_COUNT], read error [$RESULT]"
    # Increment fail count from 0, i.e. set to 1
    FAIL_COUNT=1
  fi

  WROTE_FAIL_COUNT=$(number_set "$FAILLOG" "$FAIL_COUNT")
  RESULT=$?
  if (($RESULT != 0)); then
    log_error "Failed to increment fail count [$FAIL_COUNT]/[$WROTE_FAIL_COUNT], write error [$RESULT]"
    echo 0
    return 3
  else
    echo $FAIL_COUNT
    return 0
  fi
}

# Reset fail count to 0
function fail_count_reset()
{
  NEW_FAIL_COUNT=$(number_set "$FAILLOG" 0)
  RESULT=$?
  if (($RESULT != 0)); then
    log_error "Failed to reset fail count [$NEW_FAIL_COUNT], write error [$RESULT]"
    return 2
  else
    log_info "Reset fail count to 0"
    return 0
  fi
}

# Check if Internet is available through the system default route
# and record the failure count in failure log
function test_link()
{
  if ! is_gateway_reachable "$GATEWAY"; then
    fail_count_inc 1
  else
    fail_count_reset
  fi
}

function is_gateway_reachable
{
  PING_TARGET="$1"
  PING_INTERFACE="$2"
  PING_TIMEOUT=5
  PING_COUNT=3
  PING_INTERVAL=1

  if [ -z "$PING_TARGET" ]; then
    log_error "Missing a ping target"
    exit 1
  fi

  if [ -n "$PING_INTERFACE" ]; then
    PING_OUTPUT=$($BIN_PING -q -W $PING_TIMEOUT -c $PING_COUNT -i $PING_INTERVAL -I "$PING_INTERFACE" "$PING_TARGET" 2>&1)
  else
    PING_OUTPUT=$($BIN_PING -q -W $PING_TIMEOUT -c $PING_COUNT -i $PING_INTERVAL "$PING_TARGET" 2>&1)
  fi
  PING_RESULT=$?
  log_info "Ping result $PING_RESULT: [$PING_OUTPUT]"
  return $PING_RESULT
}

function restart_interface
{
  TARGET_IF="$1"
  if [[ -z $TARGET_IF ]]; then
    log_error "Cannot restart interface, missing $TARGET_IF"
    return 1
  else
    log_info "Restarting interface $TARGET_IF"
    IFDOWN_RESULT=$(/sbin/ifdown --force $TARGET_IF 2>&1)
    log_error "ifdown of $TARGET_IF returned: $? [$IFDOWN_RESULT]"
    sleep $IF_RESTART_DELAY_S
    IFUP_RESULT=$(/sbin/ifup --force $TARGET_IF 2>&1)
    log_error "ifup of $TARGET_IF returned: $? [$IFUP_RESULT]"
  fi
}

# Default to querying the current default interfaces from routing table
if [ -z "$INTERFACES" ]; then
  INTERFACES=$(list_default_interfaces)
fi

# Ping www.google.com if nothing else is specified
if [ -z "$GATEWAY" ]; then
  GATEWAY="www.google.com"
fi

# Store failure count in default location
if [ -z "$FAILLOG" ]; then
  FAILLOG="/var/tmp/net-check-faillog.txt"
fi

if ! is_gateway_reachable "$GATEWAY"; then
  log_info "Could not reach $GATEWAY, sleeping $RETRY_DELAY_S s and retrying"
  sleep $RETRY_DELAY_S
  log_info "Retrying $GATEWAY"
  if ! is_gateway_reachable "$GATEWAY"; then
    log_error "Could not reach $GATEWAY."
    FAIL_COUNT=$(fail_count_inc 1)
    INC_RESULT=$?
    # Check if we've exceeded the failure limit
    if ((INC_RESULT == 0 && FAIL_COUNT > FAILURE_LIMIT)); then
      log_error "Failure count $FAIL_COUNT exceeds limit $FAILURE_LIMIT, restarting interfaces [$INTERFACES]"
      # Iterate all default interfaces, restart them
      for INTF in $INTERFACES; do
        restart_interface "$INTF"
      done
      # Reset failure counter regardless of result of network restart
      fail_count_reset
    else
      log_error "Failure count $FAIL_COUNT doesn't exceed limit $FAILURE_LIMIT, incrementing ($INC_RESULT) and waiting"
    fi
  else
    log_info "Network interfaces [$INTERFACES] operational."
    fail_count_reset
  fi
else
  log_info "Network interfaces [$INTERFACES] operational."
  fail_count_reset
fi
